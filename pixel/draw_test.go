package pixel

import (
	"image"
	"image/color"
	"reflect"
	"testing"
)

var testColor = color.RGBA{R: 0x55, G: 0xaa, B: 0xff, A: 0x33}

func TestFill(t *testing.T) {
	tests := []struct {
		Test Image
		Want Image
	}{
		{
			NewBitmap(8, 8),
			&Bitmap{
				Rect:   image.Rectangle{Max: image.Point{X: 8, Y: 8}},
				Pix:    []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
				Stride: 8,
				Format: MVLSBFormat,
			},
		},
		{
			NewRGB565(5, 5),
			&RGB565{
				Rect: image.Rectangle{Max: image.Point{X: 5, Y: 5}},
				Pix: []byte{
					0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f,
					0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f,
					0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f,
					0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f,
					0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f,
				},
				Stride: 10,
			},
		},
		{
			NewRGB888(3, 3),
			&RGB888{
				Rect: image.Rectangle{Max: image.Point{X: 3, Y: 3}},
				Pix: []byte{
					0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff,
					0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff,
					0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff,
				},
				Stride: 9,
			},
		},
	}
	for _, test := range tests {
		t.Run(reflect.TypeOf(test.Test).Elem().String(), func(it *testing.T) {
			Fill(test.Test, testColor)
			if !reflect.DeepEqual(test.Test, test.Want) {
				it.Fatalf("expected %T:\n%+v\ngot %T:\n%+v", test.Want, test.Want, test.Test, test.Test)
			}
		})
	}
}

func TestFillRectangle(t *testing.T) {
	tests := []struct {
		Test Image
		Want Image
	}{
		{
			NewBitmap(8, 8),
			&Bitmap{
				Rect: image.Rectangle{Max: image.Point{X: 8, Y: 8}},
				Pix: []byte{
					0b00000011,
					0b00000011,
					0b00000000,
					0b00000000,
					0b00000000,
					0b00000000,
					0b00000000,
					0b00000000,
				},
				Stride: 8,
				Format: MVLSBFormat,
			},
		},
		{
			NewRGB565(5, 5),
			&RGB565{
				Rect: image.Rectangle{Max: image.Point{X: 5, Y: 5}},
				Pix: []byte{
					0x55, 0x5f, 0x55, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x55, 0x5f, 0x55, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
				Stride: 10,
			},
		},
		{
			NewRGB888(3, 3),
			&RGB888{
				Rect: image.Rectangle{Max: image.Point{X: 3, Y: 3}},
				Pix: []byte{
					0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00,
					0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
				Stride: 9,
			},
		},
	}
	for _, test := range tests {
		t.Run(reflect.TypeOf(test.Test).Elem().String(), func(it *testing.T) {
			FillRectangle(test.Test, image.Rect(0, 0, 2, 2), testColor)
			if !reflect.DeepEqual(test.Test, test.Want) {
				it.Fatalf("expected %T:\n%+v\ngot %T:\n%+v", test.Want, test.Want, test.Test, test.Test)
			}
		})
	}
}

func TestHLine(t *testing.T) {
	tests := []struct {
		Test Image
		Want Image
	}{
		{
			NewBitmap(8, 8),
			&Bitmap{
				Rect: image.Rectangle{Max: image.Point{X: 8, Y: 8}},
				Pix: []byte{
					0b00000000,
					0b00000100,
					0b00000100,
					0b00000100,
					0b00000100,
					0b00000100,
					0b00000100,
					0b00000100,
				},
				Stride: 8,
				Format: MVLSBFormat,
			},
		},
		{
			NewRGB565(5, 5),
			&RGB565{
				Rect: image.Rectangle{Max: image.Point{X: 5, Y: 5}},
				Pix: []byte{
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
				Stride: 10,
			},
		},
		{
			NewRGB888(5, 5),
			&RGB888{
				Rect: image.Rectangle{Max: image.Point{X: 5, Y: 5}},
				Pix: []byte{
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
				Stride: 15,
			},
		},
	}
	for _, test := range tests {
		t.Run(reflect.TypeOf(test.Test).Elem().String(), func(it *testing.T) {
			HLine(test.Test, image.Pt(1, 2), 10, testColor)
			if !reflect.DeepEqual(test.Test, test.Want) {
				it.Fatalf("expected %T:\n%+v\ngot %T:\n%+v", test.Want, test.Want, test.Test, test.Test)
			}
		})
	}
}

func TestVLine(t *testing.T) {
	tests := []struct {
		Test Image
		Want Image
	}{
		{
			NewBitmap(8, 8),
			&Bitmap{
				Rect: image.Rectangle{Max: image.Point{X: 8, Y: 8}},
				Pix: []byte{
					0b00000000,
					0b11111100,
					0b00000000,
					0b00000000,
					0b00000000,
					0b00000000,
					0b00000000,
					0b00000000,
				},
				Stride: 8,
				Format: MVLSBFormat,
			},
		},
		{
			NewRGB565(5, 5),
			&RGB565{
				Rect: image.Rectangle{Max: image.Point{X: 5, Y: 5}},
				Pix: []byte{
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x55, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x55, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x55, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
				Stride: 10,
			},
		},
		{
			NewRGB888(5, 5),
			&RGB888{
				Rect: image.Rectangle{Max: image.Point{X: 5, Y: 5}},
				Pix: []byte{
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
				Stride: 15,
			},
		},
	}
	for _, test := range tests {
		t.Run(reflect.TypeOf(test.Test).Elem().String(), func(it *testing.T) {
			VLine(test.Test, image.Pt(1, 2), 10, testColor)
			if !reflect.DeepEqual(test.Test, test.Want) {
				it.Fatalf("expected %T:\n%+v\ngot %T:\n%+v", test.Want, test.Want, test.Test, test.Test)
			}
		})
	}
}

func TestLine(t *testing.T) {
	tests := []struct {
		Test Image
		Want Image
	}{
		{
			NewBitmap(8, 8),
			&Bitmap{
				Rect: image.Rectangle{Max: image.Point{X: 8, Y: 8}},
				Pix: []byte{
					0b00000000,
					0b00000010,
					0b00000100,
					0b00001000,
					0b00010000,
					0b00100000,
					0b01000000,
					0b10000000,
				},
				Stride: 8,
				Format: MVLSBFormat,
			},
		},
		{
			NewRGB565(5, 5),
			&RGB565{
				Rect: image.Rectangle{Max: image.Point{X: 5, Y: 5}},
				Pix: []byte{
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x55, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x55, 0x5f, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x5f, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x5f,
				},
				Stride: 10,
			},
		},
		{
			NewRGB888(5, 5),
			&RGB888{
				Rect: image.Rectangle{Max: image.Point{X: 5, Y: 5}},
				Pix: []byte{
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa, 0xff,
				},
				Stride: 15,
			},
		},
	}
	for _, test := range tests {
		t.Run(reflect.TypeOf(test.Test).Elem().String(), func(it *testing.T) {
			Line(test.Test, image.Pt(1, 1), image.Pt(10, 10), testColor)
			if !reflect.DeepEqual(test.Test, test.Want) {
				it.Fatalf("expected %T:\n%+v\ngot %T:\n%+v", test.Want, test.Want, test.Test, test.Test)
			}
		})
	}
}

func TestCircle(t *testing.T) {
	tests := []struct {
		Test Image
		Want Image
	}{
		{
			NewBitmap(8, 8),
			&Bitmap{
				Rect: image.Rectangle{Max: image.Point{X: 8, Y: 8}},
				Pix: []byte{
					0b00000000,
					0b01110000,
					0b10001100,
					0b00000100,
					0b00000010,
					0b00000010,
					0b00000010,
					0b00000100,
				},
				Stride: 8,
				Format: MVLSBFormat,
			},
		},
		{
			NewRGB565(8, 8),
			&RGB565{
				Rect: image.Rectangle{Max: image.Point{X: 8, Y: 8}},
				Pix: []byte{
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x5f, 0x55, 0x5f, 0x55, 0x5f, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x55, 0x5f, 0x55, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x5f,
					0x00, 0x00, 0x00, 0x00, 0x55, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x55, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x55, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x55, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x55, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
				Stride: 16,
			},
		},
		{
			NewRGB888(8, 8),
			&RGB888{
				Rect: image.Rectangle{Max: image.Point{X: 8, Y: 8}},
				Pix: []byte{
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa, 0xff, 0x55, 0xaa, 0xff,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa, 0xff,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa, 0xff, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
				Stride: 24,
			},
		},
	}
	for _, test := range tests {
		t.Run(reflect.TypeOf(test.Test).Elem().String(), func(it *testing.T) {
			Circle(test.Test, image.Pt(5, 5), 4, testColor)
			if !reflect.DeepEqual(test.Test, test.Want) {
				it.Fatalf("expected %T:\n%+v\ngot %T:\n%+v", test.Want, test.Want, test.Test, test.Test)
			}
		})
	}
}

/*
// Only used for debugging tests:
func testOutput(t *testing.T, i Image) {
	t.Helper()
	f, err := os.Create(reflect.TypeOf(i).Elem().String() + ".png")
	if err != nil {
		t.Error(err)
		return
	}
	if err = png.Encode(f, i); err != nil {
		_ = f.Close()
		_ = os.Remove(f.Name())
		t.Error(err)
		return
	}
	if err = f.Close(); err != nil {
		t.Error(err)
		return
	}
	t.Logf("saved as %s", f.Name())
}
*/
